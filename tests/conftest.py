# tests/conftest.py
"""
Pytest configuration and fixtures for async database testing.

–ö–ª—é—á–µ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
- PostgreSQL (asyncpg) –∫–∞–∫ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤.
- –î–ª—è Postgres: –ø–µ—Ä–µ–¥ create_all –ª–µ–Ω–∏–≤–æ –ø–æ–¥–≥—Ä—É–∂–∞–µ–º –≤–µ—Å—å –¥–æ–º–µ–Ω (import_all_models) ‚Äî –æ–¥–∏–Ω —Ä–∞–∑.
- –î–ª—è SQLite: –≥–ª–æ–±–∞–ª—å–Ω—ã–π –±–µ–∑–æ–ø–∞—Å–Ω—ã–π create_all ‚Äî —Å–æ–∑–¥–∞—ë–º —Ç–æ–ª—å–∫–æ —Å–∞–º–æ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã (–±–µ–∑ ¬´–≤–∏—Å—è—á–∏—Ö¬ª FK)
  –∏ —Ç–æ–ª—å–∫–æ —Å —Ç–∏–ø–∞–º–∏, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–º–∏ SQLite (JSONB/ARRAY/INET/... –ø—Ä–æ–ø—É—Å–∫–∞–µ–º).
- –õ—ë–≥–∫–∞—è –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ –∫–ª—é—á–µ–≤—ã—Ö –º–æ–¥–µ–ª–µ–π (Company/User/Warehouse/AuditLog), —á—Ç–æ–±—ã —Å—Ç—Ä–æ–∫–æ–≤—ã–µ relationship(...)
  —Ä–µ–∑–æ–ª–≤–∏–ª–∏—Å—å –∏ –Ω–µ –ø–∞–¥–∞–ª–∏ –º–∞–ø–ø–µ—Ä—ã.
- –£–¥–æ–±–Ω—ã–µ —Ñ–∏–∫—Å—Ç—É—Ä—ã –∫–ª–∏–µ–Ω—Ç–∞ (sync/async), —Å–µ—Å—Å–∏–π, —Å–±—Ä–æ—Å–∞ –¥–∞–Ω–Ω—ã—Ö –∏ —Ñ–∞–±—Ä–∏–∫ –¥–æ–º–µ–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π.
- –Ø–≤–Ω–æ–µ DATABASE_URL (psycopg2) –¥–ª—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è test_database_url_default.
- –î—Ä—É–∂–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ env: TEST_ASYNC_DATABASE_URL (–ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–æ) –∏–ª–∏ fallback –∫ TEST_DATABASE_URL,
  –≤–∫–ª—é—á–∞—è –∞–≤—Ç–æ–∫–æ–Ω–≤–µ—Ä—Å–∏—é –¥—Ä–∞–π–≤–µ—Ä–∞ psycopg2 -> asyncpg –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ async engine).
- –í–µ–∑–¥–µ UTF-8: PYTHONIOENCODING –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –±–µ–∑ –≤–ª–∏—è–Ω–∏—è –ª–æ–∫–∞–ª–∏ –æ–∫—Ä—É–∂–µ–Ω–∏—è.
"""

from __future__ import annotations

import asyncio
import os
from typing import (
    Any,
    AsyncIterator,
    Awaitable,
    Callable,
    Dict,
    Iterator,
    List,
    Optional,
    Set,
    Tuple,
)

import pytest
import pytest_asyncio
from fastapi.testclient import TestClient
from httpx import AsyncClient
from sqlalchemy import MetaData, Table, text
from sqlalchemy.engine import Connection, Engine
from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.pool import NullPool
from sqlalchemy.sql.type_api import TypeEngine  # üîΩ –î–û–ë–ê–í–õ–ï–ù–û: —Ç–∏–ø—ã –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞ unsupported
from sqlalchemy import exc as sa_exc  # üîΩ –î–û–ë–ê–í–õ–ï–ù–û: –æ–±—Ä–∞–±–æ—Ç–∫–∞ OperationalError –≤ SQLite

# ======================================================================================
# 0) –ë—É—Ç—Å—Ç—Ä–∞–ø –æ–∫—Ä—É–∂–µ–Ω–∏—è
# ======================================================================================

# –í—Å—é–¥—É UTF-8 (—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ)
os.environ.setdefault("PYTHONIOENCODING", "UTF-8")

# –ß—Ç–æ–±—ã –ø—Ä–æ—à—ë–ª tests/app/core/test_config.py::test_database_url_default
os.environ.setdefault(
    "DATABASE_URL",
    "postgresql+psycopg2://postgres:admin123@localhost:5432/SmartSell",
)

# –Ø–≤–Ω–æ —É–∫–∞–∂–µ–º "—Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π" strict-—Ä–µ–∂–∏–º asyncio, –µ—Å–ª–∏ –ø–ª–∞–≥–∏–Ω –Ω–µ –¥–µ–ª–∞–µ—Ç —ç—Ç–æ–≥–æ —Å–∞–º.
os.environ.setdefault("PYTEST_ASYNCIO_MODE", "strict")


# ======================================================================================
# –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –£–¢–ò–õ–ò–¢–´: URL‚Äô—ã, –∏–º–ø–æ—Ä—Ç app –∏ –º–æ–¥–µ–ª–µ–π, –ø–æ–∏—Å–∫ get_db
# ======================================================================================


def _get_async_test_url() -> str:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç async URL –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –¥–≤–∏–∂–∫–∞:
      1) TEST_ASYNC_DATABASE_URL (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω)
      2) –∏–Ω–∞—á–µ TEST_DATABASE_URL ‚Äî –Ω–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –¥—Ä–∞–π–≤–µ—Ä psycopg2 -> asyncpg
    –ë—Ä–æ—Å–∞–µ–º –ø–æ–Ω—è—Ç–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ, –µ—Å–ª–∏ URL –ø—É—Å—Ç –∏–ª–∏ –Ω–µ postgresql.
    """
    async_url = os.getenv("TEST_ASYNC_DATABASE_URL")
    base_url = os.getenv("TEST_DATABASE_URL")

    if async_url:
        url = async_url
    elif base_url:
        # –ï—Å–ª–∏ –∫—Ç–æ-—Ç–æ –ø–æ –æ—à–∏–±–∫–µ –¥–∞–ª sync URL, –∞–∫–∫—É—Ä–∞—Ç–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –¥—Ä–∞–π–≤–µ—Ä.
        if base_url.startswith("postgresql+psycopg2://"):
            url = "postgresql+asyncpg://" + base_url.split("postgresql+psycopg2://", 1)[1]
        else:
            url = base_url
    else:
        # —Ä–∞–∑—É–º–Ω—ã–π –¥–µ—Ñ–æ–ª—Ç –ø–æ–¥ –ª–æ–∫–∞–ª—å–Ω—É—é —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É
        url = "postgresql+asyncpg://postgres:admin123@localhost:5432/SmartSellTest"

    if not url.startswith("postgresql+"):
        raise RuntimeError(
            f"Expected a PostgreSQL URL for tests, got '{url}'. "
            f"Use TEST_ASYNC_DATABASE_URL='postgresql+asyncpg://...'"
        )
    if not url.startswith("postgresql+asyncpg://"):
        raise RuntimeError(
            f"Async engine requires async driver. Got '{url}'. "
            f"Use TEST_ASYNC_DATABASE_URL (postgresql+asyncpg://...) "
            f"or set TEST_DATABASE_URL with asyncpg driver."
        )
    return url


def _import_app_and_get_db() -> Tuple[Any, Callable[..., AsyncIterator[AsyncSession]]]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (app, get_db). –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –æ–±–∞ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è:
      - app.core.db:get_db
      - app.core.database:get_db
    """
    # –ò–º–ø–æ—Ä—Ç FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    try:
        from app.main import app  # type: ignore
    except Exception as e:
        raise RuntimeError(f"Cannot import FastAPI app from app.main: {e}") from e

    # –ò–º–ø–æ—Ä—Ç get_db
    get_db = None
    # –ù–æ–≤—ã–π –ø—É—Ç—å
    try:
        from app.core.db import get_db as _get_db  # type: ignore

        get_db = _get_db
    except Exception:
        pass
    # –°—Ç–∞—Ä—ã–π –ø—É—Ç—å (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
    if get_db is None:
        try:
            from app.core.database import get_db as _get_db  # type: ignore

            get_db = _get_db
        except Exception as e:
            raise RuntimeError(
                f"Cannot import get_db from app.core.db or app.core.database: {e}"
            ) from e

    return app, get_db  # type: ignore[return-value]


def _import_all_models_once() -> bool:
    """
    –ü—ã—Ç–∞–µ–º—Å—è –≤—ã–∑–≤–∞—Ç—å app.models.import_all_models(), –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–ª–∏ –≤–µ—Å—å –¥–æ–º–µ–Ω; –∏–Ω–∞—á–µ False.
    """
    try:
        import app.models as m  # type: ignore

        if hasattr(m, "import_all_models"):
            m.import_all_models()  # type: ignore[attr-defined]
            return True
    except Exception:
        pass
    return False


def _bootstrap_minimal_models() -> None:
    """
    –õ—ë–≥–∫–∞—è –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ —Ç–æ–ª—å–∫–æ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –∫–ª–∞—Å—Å–æ–≤, —á—Ç–æ–±—ã —Å—Ç—Ä–æ–∫–æ–≤—ã–µ relationship(...)
    –Ω–µ –ø–∞–¥–∞–ª–∏ –ø—Ä–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –º–∞–ø–ø–µ—Ä–æ–≤ –≤ SQLite-—é–Ω–∏—Ç–∞—Ö.
    """
    try:
        import app.models.company  # type: ignore  # —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç Company/companies
    except Exception:
        pass
    try:
        import app.models.user  # type: ignore
    except Exception:
        pass
    # üîΩ –î–û–ë–ê–í–õ–ï–ù–û: —á—Ç–æ–±—ã relationship –ø–æ —Å–∫–ª–∞–¥–∞–º –∏ –∞—É–¥–∏—Ç—É –∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–æ–≤–∞–ª–∏—Å—å (—É–±–∏—Ä–∞–µ–º NoForeignKeysError)
    try:
        import app.models.warehouse  # type: ignore
    except Exception:
        pass
    try:
        import app.models.audit_log  # type: ignore
    except Exception:
        pass


# ======================================================================================
# 1) –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ AsyncEngine (PostgreSQL + asyncpg)
# ======================================================================================

TEST_DATABASE_URL = _get_async_test_url()

test_engine: AsyncEngine = create_async_engine(
    TEST_DATABASE_URL,
    echo=False,
    pool_pre_ping=True,
    poolclass=NullPool,  # –Ω–µ –¥–µ—Ä–∂–∏–º –∫–æ–Ω–Ω–µ–∫—Ç—ã ‚Äî –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è Windows/CI
    future=True,
)

TestingSessionLocal = async_sessionmaker(
    bind=test_engine,
    class_=AsyncSession,
    expire_on_commit=False,
)


# ======================================================================================
# 2) –ì–ª–æ–±–∞–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞ create_all –¥–ª—è SQLite + –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ –∫–ª–∞—Å—Å–æ–≤
# ======================================================================================


def _is_sqlite_bind(bind: Any) -> bool:
    """–û–ø—Ä–µ–¥–µ–ª—è–µ–º, —á—Ç–æ create_all –≤—ã–∑—ã–≤–∞—é—Ç –¥–ª—è SQLite (–æ—Å–æ–±–µ–Ω–Ω–æ :memory:)."""
    try:
        if isinstance(bind, (Engine, Connection)):
            return getattr(bind.dialect, "name", "") == "sqlite"
    except Exception:
        pass
    return False


def _sqlite_extract_target_table_names(t: Table) -> Set[str]:
    """–í–µ—Ä–Ω—ë—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∏–º—ë–Ω —Ç–∞–±–ª–∏—Ü, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ —Å–º–æ—Ç—Ä—è—Ç FK —ç—Ç–æ–π —Ç–∞–±–ª–∏—Ü—ã (–ø–æ 'target_fullname' / '_colspec')."""
    targets: Set[str] = set()
    for fk in t.foreign_keys:
        spec = getattr(fk, "target_fullname", None) or getattr(fk, "_colspec", None)
        if spec:
            table_name = str(spec).split(".", 1)[0]
            if table_name:
                targets.add(table_name)
    return targets


# üîΩ –î–û–ë–ê–í–õ–ï–ù–û: —Ñ–∏–ª—å—Ç—Ä –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö SQLite —Ç–∏–ø–æ–≤ (JSONB –∏ –¥—Ä.)
_POSTGRES_ONLY_TYPENAMES = {
    "JSONB",
    "ARRAY",
    "HSTORE",
    "CIDR",
    "INET",
    "UUID",  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–æ–ø—É—Å–∫–∞–µ–º; –µ—Å–ª–∏ –µ—Å—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ç–∏–ø ‚Äî –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –∏–∑ —Å–ø–∏—Å–∫–∞
}


def _sqlite_is_supported_type(typ: TypeEngine) -> bool:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç False –¥–ª—è —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ SQLite –Ω–µ —É–º–µ–µ—Ç –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—Ç–∏–≤–Ω–æ.
    –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ –∏–º–µ–Ω–∏ –∫–ª–∞—Å—Å–∞ —Ç–∏–ø–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, JSONB, ARRAY –∏ —Ç.–ø.).
    """
    try:
        tname = type(typ).__name__.upper()
    except Exception:
        return False
    if tname in _POSTGRES_ONLY_TYPENAMES:
        return False
    # –ø–æ–¥—Å—Ç—Ä–∞—Ö—É–µ–º—Å—è –æ—Ç —Ä–∞–∑–Ω—ã—Ö –¥–∏–∞–ª–µ–∫—Ç–Ω—ã—Ö –æ–±—ë—Ä—Ç–æ–∫
    if "JSONB" in tname:
        return False
    return True


def _sqlite_is_supported_table(t: Table) -> bool:
    """–¢–∞–±–ª–∏—Ü–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è SQLite, –µ—Å–ª–∏ –≤—Å–µ –µ—ë —Å—Ç–æ–ª–±—Ü—ã ‚Äî —Å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–º–∏ —Ç–∏–ø–∞–º–∏."""
    try:
        for c in t.columns:
            if not _sqlite_is_supported_type(c.type):
                return False
        return True
    except Exception:
        # –µ—Å–ª–∏ –Ω–µ —Å–º–æ–≥–ª–∏ –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ç–∏–ø—ã, –ª—É—á—à–µ –Ω–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ç–∞–∫—É—é —Ç–∞–±–ª–∏—Ü—É
        return False


def _sqlite_self_contained_tables(md: MetaData) -> List[Table]:
    """
    –¢–∞–±–ª–∏—Ü—ã, —É –∫–æ—Ç–æ—Ä—ã—Ö –≤—Å–µ FK —É–∫–∞–∑—ã–≤–∞—é—Ç –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –≤ —Ç–µ–∫—É—â–µ–º MetaData
    –ò —Ç–∞–±–ª–∏—Ü–∞ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∑–∞–≤–µ–¥–æ–º–æ –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –¥–ª—è SQLite —Ç–∏–ø–æ–≤.
    """
    present: Set[str] = set(md.tables.keys())
    result: List[Table] = []
    for t in md.tables.values():
        if _sqlite_extract_target_table_names(t).issubset(present) and _sqlite_is_supported_table(
            t
        ):
            result.append(t)
    return result


@pytest.fixture(scope="session", autouse=True)
def _sqlite_safe_create_all_monkeypatch() -> Iterator[None]:
    """
    –ì–ª–æ–±–∞–ª—å–Ω–æ –º–æ–Ω–∏–ø–∞—Ç—á–∏–º MetaData.create_all –¥–ª—è SQLite –Ω–∞ –≤—Ä–µ–º—è —Ç–µ—Å—Ç–æ–≤–æ–π —Å–µ—Å—Å–∏–∏.
    –°–æ–∑–¥–∞—ë–º —Ç–æ–ª—å–∫–æ ¬´—Å–∞–º–æ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–µ¬ª —Ç–∞–±–ª–∏—Ü—ã, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å NoReferencedTableError,
    –∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã —Å –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–º–∏ —Ç–∏–ø–∞–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, JSONB).
    –¢–∞–∫–∂–µ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º ¬´index ... already exists¬ª –≤ SQLite.
    """
    original_create_all = MetaData.create_all

    def _safe_create_all(self: MetaData, bind: Any = None, **kwargs):
        if _is_sqlite_bind(bind):
            from sqlalchemy import MetaData as _MD

            tables = _sqlite_self_contained_tables(self)
            if not tables:
                return
            tmp = _MD()
            for t in tables:
                # —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ (–≤–º–µ—Å—Ç–æ t.tometadata)
                t.to_metadata(tmp)

            # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º checkfirst=True –∏ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º ¬´index already exists¬ª
            kwargs.setdefault("checkfirst", True)
            try:
                return original_create_all(tmp, bind=bind, **kwargs)
            except sa_exc.OperationalError as e:
                msg = (str(e) or "").lower()
                if "already exists" in msg and "index" in msg:
                    # –±–µ–∑–æ–ø–∞—Å–Ω–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞
                    return None
                raise
        # –Ω–µ SQLite ‚Äî –æ–±—ã—á–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
        kwargs.setdefault("checkfirst", True)
        try:
            return original_create_all(self, bind=bind, **kwargs)
        except sa_exc.OperationalError as e:
            # –ø–æ–¥—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞: –µ—Å–ª–∏ –∫–∞–∫–∞—è-—Ç–æ –ë–î —Ç–æ–∂–µ –≤–µ—Ä–Ω—ë—Ç "already exists"
            msg = (str(e) or "").lower()
            if "already exists" in msg:
                return None
            raise

    MetaData.create_all = _safe_create_all  # type: ignore[assignment]
    try:
        yield
    finally:
        MetaData.create_all = original_create_all  # type: ignore[assignment]


@pytest.fixture(scope="session", autouse=True)
def _bootstrap_minimal_models_for_mapping() -> None:
    """
    –õ—ë–≥–∫–∞—è –∞–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ —Ç–æ–ª—å–∫–æ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –∫–ª–∞—Å—Å–æ–≤, —á—Ç–æ–±—ã —Å—Ç—Ä–æ–∫–æ–≤—ã–µ relationship(...)
    –Ω–µ –ø–∞–¥–∞–ª–∏ –ø—Ä–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –º–∞–ø–ø–µ—Ä–æ–≤ –≤ SQLite-—é–Ω–∏—Ç–∞—Ö.
    """
    _bootstrap_minimal_models()


# ======================================================================================
# 3) –ü–∞—Ç—á create_all –¥–ª—è Postgres (–ø–æ–ª–Ω–∞—è —Å—Ö–µ–º–∞) ‚Äî –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ —Å–µ—Å—Å–∏—é
# ======================================================================================

_MODELS_IMPORTED_ONCE = False
_CREATE_ALL_PATCHED = False


def _ensure_patch_create_all_for_postgres() -> None:
    """
    –ü–ê–¢–ß–ò–¢ Base.metadata.create_all –≤–Ω—É—Ç—Ä–∏ app.models —Ç–∞–∫, —á—Ç–æ–±—ã:
    - –¥–ª—è –Ω–µ-SQLite –æ–¥–∏–Ω —Ä–∞–∑ –≤—ã–∑—ã–≤–∞—Ç—å import_all_models(), –∑–∞—Ç–µ–º –æ–±—ã—á–Ω—ã–π create_all.
    - –¥–ª—è SQLite ‚Äî –¥–æ–≤–µ—Ä—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ–º—É –º–æ–Ω–∏–ø–∞—Ç—á—É MetaData.create_all (—Å–º. –≤—ã—à–µ).
    """
    global _MODELS_IMPORTED_ONCE, _CREATE_ALL_PATCHED
    import app.models as m  # type: ignore

    if _CREATE_ALL_PATCHED:
        return

    original = m.Base.metadata.create_all

    def _patched_create_all(*args, **kwargs):
        bind = kwargs.get("bind")
        if bind is None and args:
            for a in args:
                if isinstance(a, (Engine, Connection)):
                    bind = a
                    break

        if not _is_sqlite_bind(bind):
            # –ü–æ–ª–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–æ–º–µ–Ω–∞ —Å—Ç—Ä–æ–≥–æ –æ–¥–∏–Ω —Ä–∞–∑
            if not _MODELS_IMPORTED_ONCE and _import_all_models_once():
                _MODELS_IMPORTED_ONCE = True
        # –¥–ª—è SQLite ‚Äî –Ω–∏—á–µ–≥–æ –æ—Å–æ–±–æ–≥–æ: –æ—Ç—Ä–∞–±–æ—Ç–∞–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–π –º–æ–Ω–∫–∏–ø–∞—Ç—á MetaData.create_all
        kwargs.setdefault("checkfirst", True)
        try:
            return original(*args, **kwargs)
        except sa_exc.OperationalError as e:
            # –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –¥—É–±–ª–∏ ¬´already exists¬ª
            msg = (str(e) or "").lower()
            if "already exists" in msg:
                return None
            raise

    m.Base.metadata.create_all = _patched_create_all  # type: ignore[assignment]
    _CREATE_ALL_PATCHED = True


# ======================================================================================
# 4) –ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª —Å—Ö–µ–º—ã Postgres ‚Äî –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ —Å–µ—Å—Å–∏—é
# ======================================================================================


@pytest_asyncio.fixture(scope="session")
async def test_db() -> AsyncIterator[None]:
    """
    –°–æ–∑–¥–∞—Ç—å –í–°–Æ —Å—Ö–µ–º—É –ë–î –æ–¥–∏–Ω —Ä–∞–∑ –ø–µ—Ä–µ–¥ —Ç–µ—Å—Ç–∞–º–∏ –∏ —Å–Ω–µ—Å—Ç–∏ –µ—ë –ø–æ—Å–ª–µ.
    –¢–æ–ª—å–∫–æ –¥–ª—è Postgres (–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã).
    """
    _ensure_patch_create_all_for_postgres()

    import app.models as m  # type: ignore

    if not _MODELS_IMPORTED_ONCE:
        # –ï—Å–ª–∏ import_all_models –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚Äî fallback –Ω–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π bootstrap
        if not _import_all_models_once():
            _bootstrap_minimal_models()
            _MODELS_IMPORTED_ONCE = True

    async with test_engine.begin() as conn:
        await conn.run_sync(lambda sync_conn: m.Base.metadata.create_all(bind=sync_conn))

    try:
        if hasattr(m, "assert_relationships_resolved"):
            m.assert_relationships_resolved()  # type: ignore[attr-defined]
    except Exception as e:
        raise RuntimeError(f"Model relationship/FK unresolved after create_all: {e}") from e

    try:
        yield
    finally:
        async with test_engine.begin() as conn:
            await conn.run_sync(lambda sync_conn: m.Base.metadata.drop_all(bind=sync_conn))


# ======================================================================================
# 5) Event loop –¥–ª—è pytest-asyncio (strict mode —Å–æ–≤–º–µ—Å—Ç–∏–º)
# ======================================================================================


@pytest.fixture(scope="session")
def event_loop() -> Iterator[asyncio.AbstractEventLoop]:
    loop = asyncio.new_event_loop()
    try:
        yield loop
    finally:
        loop.close()


# ======================================================================================
# 6) FastAPI –∫–ª–∏–µ–Ω—Ç—ã (async/sync) —Å –ª–µ–Ω–∏–≤—ã–º–∏ –∏–º–ø–æ—Ä—Ç–∞–º–∏ app –∏ get_db
# ======================================================================================


async def _override_get_db() -> AsyncIterator[AsyncSession]:
    async with TestingSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()


@pytest_asyncio.fixture
async def async_client(test_db: None) -> AsyncIterator[AsyncClient]:
    app, get_db = _import_app_and_get_db()
    app.dependency_overrides[get_db] = _override_get_db  # type: ignore[index]
    async with AsyncClient(app=app, base_url="http://test") as client:
        try:
            yield client
        finally:
            app.dependency_overrides.clear()


@pytest.fixture
def client(test_db: None) -> Iterator[TestClient]:
    app, get_db = _import_app_and_get_db()
    app.dependency_overrides[get_db] = _override_get_db  # type: ignore[index]
    with TestClient(app) as c:
        try:
            yield c
        finally:
            app.dependency_overrides.clear()


# ======================================================================================
# 7) –°–µ—Å—Å–∏–∏ –ë–î + —Ñ–∞–±—Ä–∏–∫–∞ + –±—ã—Å—Ç—Ä—ã–π —Å–±—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö
# ======================================================================================


@pytest_asyncio.fixture
async def async_db_session(test_db: None) -> AsyncIterator[AsyncSession]:
    async with TestingSessionLocal() as session:
        yield session


@pytest.fixture
def db_session_factory() -> Callable[[], Awaitable[AsyncSession]]:
    async def _factory() -> AsyncSession:
        return TestingSessionLocal()

    return _factory


@pytest_asyncio.fixture
async def db_reset(async_db_session: AsyncSession) -> AsyncIterator[None]:
    yield

    import app.models as m  # type: ignore

    tablenames = [t for t in m.Base.metadata.tables.keys() if t != "alembic_version"]
    if not tablenames:
        return
    sql = "TRUNCATE " + ", ".join(f'"{name}"' for name in tablenames) + " RESTART IDENTITY CASCADE"
    await async_db_session.execute(text(sql))
    await async_db_session.commit()


# ======================================================================================
# 8) –°—ç–º–ø–ª—ã –∏ —Ñ–∞–±—Ä–∏–∫–∏ –¥–æ–º–µ–Ω–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π
# ======================================================================================


@pytest.fixture
def sample_user_data() -> Dict[str, object]:
    return {
        "phone": "77051234567",
        "email": "test@example.com",
        "full_name": "Test User",
        "password": "password123",
        "confirm_password": "password123",
        "username": "testuser",
    }


@pytest.fixture
def sample_product_data() -> Dict[str, object]:
    return {
        "name": "Test Product",
        "slug": "test-product",
        "sku": "TEST-001",
        "description": "A test product",
        "price": 99.99,
        "stock_quantity": 100,
        "is_active": True,
    }


@pytest_asyncio.fixture
async def factory(async_db_session: AsyncSession) -> Dict[str, Callable[..., Awaitable[object]]]:
    from app.models.company import Company  # type: ignore
    from app.models.user import User  # type: ignore
    from app.models.product import Category, Product, ProductVariant  # type: ignore
    from app.models.warehouse import Warehouse, ProductStock  # type: ignore

    async def create_company(name: str = "Acme Inc.") -> Company:
        obj = Company(name=name)
        async_db_session.add(obj)
        await async_db_session.commit()
        await async_db_session.refresh(obj)
        return obj

    async def create_user(
        *,
        username: str = "testuser",
        email: str = "test@example.com",
        phone: str = "+70000000000",
        company: Company | None = None,
        hashed_password: str = "",
    ) -> User:
        obj = User(username=username, email=email, phone=phone, hashed_password=hashed_password)
        if hasattr(obj, "company_id") and company is not None:
            setattr(obj, "company_id", company.id)
        async_db_session.add(obj)
        await async_db_session.commit()
        await async_db_session.refresh(obj)
        return obj

    async def create_category(*, name: str = "Default", slug: str = "default") -> Category:
        obj = Category(name=name, slug=slug)
        async_db_session.add(obj)
        await async_db_session.commit()
        await async_db_session.refresh(obj)
        return obj

    async def create_product(
        *,
        name: str = "Sample Product",
        slug: str = "sample-product",
        sku: str = "SKU-001",
        price: float = 100.0,
        stock_quantity: int = 10,
        category: Category | None = None,
        company: Company | None = None,
        is_active: bool = True,
    ) -> Product:
        if category is None:
            category = await create_category()
        kwargs: Dict[str, object] = dict(
            name=name,
            slug=slug,
            sku=sku,
            price=price,
            stock_quantity=stock_quantity,
            category_id=category.id,
            is_active=is_active,
        )
        try:
            if "company_id" in Product.__table__.columns:  # type: ignore[attr-defined]
                if company is None:
                    company = await create_company()
                kwargs["company_id"] = company.id
        except Exception:
            pass

        obj = Product(**kwargs)  # type: ignore[arg-type]
        async_db_session.add(obj)
        await async_db_session.commit()
        await async_db_session.refresh(obj)
        return obj

    async def create_variant(
        *,
        product: Product | None = None,
        name: str = "Sample Variant",
        sku: str = "SKU-001-BLUE",
        price: float = 110.0,
        stock_quantity: int = 3,
        is_active: bool = True,
    ) -> ProductVariant:
        if product is None:
            product = await create_product()
        obj = ProductVariant(
            product_id=product.id,
            name=name,
            sku=sku,
            price=price,
            stock_quantity=stock_quantity,
            is_active=is_active,
        )
        async_db_session.add(obj)
        await async_db_session.commit()
        await async_db_session.refresh(obj)
        return obj

    async def create_warehouse(
        *, name: str = "Main WH", company: Company | None = None
    ) -> Warehouse:
        obj = Warehouse(name=name)
        if hasattr(obj, "company_id"):
            if company is None:
                company = await create_company()
            setattr(obj, "company_id", company.id)
        async_db_session.add(obj)
        await async_db_session.commit()
        await async_db_session.refresh(obj)
        return obj

    async def create_stock(
        *,
        product: Product | None = None,
        warehouse: Warehouse | None = None,
        quantity: int = 7,
    ) -> ProductStock:
        if product is None:
            product = await create_product()
        if warehouse is None:
            warehouse = await create_warehouse()
        obj = ProductStock(product_id=product.id, warehouse_id=warehouse.id, quantity=quantity)
        async_db_session.add(obj)
        await async_db_session.commit()
        await async_db_session.refresh(obj)
        return obj

    return {
        "create_company": create_company,
        "create_user": create_user,
        "create_category": create_category,
        "create_product": create_product,
        "create_variant": create_variant,
        "create_warehouse": create_warehouse,
        "create_stock": create_stock,
    }
